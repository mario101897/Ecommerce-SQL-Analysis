USE ecommerce;

-- Query #1: Calculate the total sales for the platform
-- Purpose: Summarize the revenue generated by all orders. Key metric to measure overall performance.

SELECT FORMAT(SUM(TotalAmount), 2) AS TotalSales 
FROM Orders;

-- Query #2: Find the top-selling product categories
-- Purpose: Identify the most popular product categories by sales volume, informing marketing strategies and inventory decisions.

SELECT P.Category, SUM(OD.Quantity) AS TotalSold
FROM OrderDetails OD
JOIN Products P ON OD.ProductID = P.ProductID
GROUP BY P.Category
ORDER BY TotalSold DESC;

-- Query #3: Identify the most valuable customers (highest spending)
-- Purpose: Highlight the top 5 customers contributing the most revenue. Useful for loyalty programs or personalized promotions.

SELECT C.CustomerID, C.Name, FORMAT(SUM(O.TotalAmount), 2) AS TotalSpent
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY TotalSpent DESC
LIMIT 5;

-- Query #4: Find products that need restocking (low inventory)
-- Purpose: Identify products with low inventory to prioritize restocking and avoid stockouts.

SELECT ProductID, ProductName, StockQuantity 
FROM Products
WHERE StockQuantity < 10
ORDER BY StockQuantity ASC;

-- Query #5: Calculate the average order value per customer
-- Purpose: Measure customer spending behavior. Identifies high-value customers for potential upselling or retention efforts.

SELECT C.CustomerID, C.Name, FORMAT(AVG(O.TotalAmount), 2) AS AvgOrderValue
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY AvgOrderValue DESC;

-- Query #6: Find monthly sales trends
-- Purpose: Show sales performance over time to identify trends or seasonality.

SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, FORMAT(SUM(TotalAmount), 2) AS MonthlySales
FROM Orders
GROUP BY Month
ORDER BY Month ASC;

-- Query #7: Customer segmentation based on spending
-- Purpose: Categorize customers into segments (e.g., high-value) for targeted marketing campaigns or promotions.

SELECT 
    C.CustomerID, 
    C.Name, 
    CASE 
        WHEN SUM(O.TotalAmount) > 1000 THEN 'High-Value'
        WHEN SUM(O.TotalAmount) BETWEEN 500 AND 1000 THEN 'Medium-Value'
        ELSE 'Low-Value'
    END AS CustomerSegment,
    FORMAT(SUM(O.TotalAmount), 2) AS TotalSpent
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY TotalSpent DESC;

-- Query #8: Identify most profitable products
-- Purpose: Identify the top revenue-generating products. Helps focus on items driving profitability and guides procurement or promotion decisions.

SELECT 
    P.ProductID, 
    P.ProductName, 
    FORMAT(SUM(OD.Quantity * OD.Price), 2) AS TotalRevenue
FROM Products P
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY P.ProductID, P.ProductName
ORDER BY TotalRevenue DESC
LIMIT 5;

-- Query #9: Supplier contribution to revenue
-- Purpose: Measure how much revenue each supplierâ€™s products generate. Useful for negotiations or evaluating supplier performance.

SELECT 
    S.SupplierID, 
    S.SupplierName, 
    FORMAT(SUM(OD.Quantity * OD.Price), 2) AS RevenueGenerated
FROM Suppliers S
JOIN Products P ON S.SupplierID = P.SupplierID
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY S.SupplierID, S.SupplierName
ORDER BY RevenueGenerated DESC;

-- Query #10: Identify frequently bundled products
-- Purpose: Detect commonly purchased product pairs (bundles). Informs cross-selling strategies and bundle promotions.

SELECT 
    OD1.ProductID AS Product1, 
    P1.ProductName AS Product1Name, 
    OD2.ProductID AS Product2, 
    P2.ProductName AS Product2Name, 
    COUNT(*) AS BundleCount
FROM OrderDetails OD1
JOIN OrderDetails OD2 ON OD1.OrderID = OD2.OrderID AND OD1.ProductID < OD2.ProductID
JOIN Products P1 ON OD1.ProductID = P1.ProductID
JOIN Products P2 ON OD2.ProductID = P2.ProductID
GROUP BY Product1, Product2
ORDER BY BundleCount DESC
LIMIT 5;

-- Query #11: Predict stock-out risk
-- Purpose: Predict which products are at risk of stockout within the next 30 days based on average daily sales.

SELECT 
    P.ProductID, 
    P.ProductName, 
    P.StockQuantity, 
    FORMAT(AVG(OD.Quantity), 2) AS AvgDailySales, 
    ROUND(P.StockQuantity / AVG(OD.Quantity), 2) AS DaysUntilStockOut
FROM Products P
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY P.ProductID, P.ProductName, P.StockQuantity
HAVING DaysUntilStockOut < 30
ORDER BY DaysUntilStockOut ASC;

-- Query #12: Lifetime value of customers (LTV)
-- Purpose: Calculate customer lifetime value (LTV) based on total revenue and average order value. Guides customer retention efforts.

SELECT 
    C.CustomerID, 
    C.Name, 
    FORMAT(SUM(O.TotalAmount), 2) AS TotalRevenue, 
    COUNT(O.OrderID) AS TotalOrders, 
    FORMAT(SUM(O.TotalAmount) / COUNT(O.OrderID), 2) AS AvgOrderValue
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY TotalRevenue DESC;

-- Query #13: Revenue trends by category over time
-- Purpose: Analyze how revenue from each product category changes over time to spot trends or shifts in customer preferences.

SELECT 
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month, 
    P.Category, 
    FORMAT(SUM(OD.Quantity * OD.Price), 2) AS MonthlyRevenue
FROM Orders O
JOIN OrderDetails OD ON O.OrderID = OD.OrderID
JOIN Products P ON OD.ProductID = P.ProductID
GROUP BY Month, P.Category
ORDER BY Month ASC, MonthlyRevenue DESC;

-- Query #14: Average time between orders for each customer
-- Purpose: Measure customer buying frequency. Useful for creating personalized re-engagement strategies.

SELECT 
    C.CustomerID, 
    C.Name, 
    FORMAT(AVG(DATEDIFF(O2.OrderDate, O1.OrderDate)), 2) AS AvgDaysBetweenOrders
FROM Customers C
JOIN Orders O1 ON C.CustomerID = O1.CustomerID
JOIN Orders O2 ON C.CustomerID = O2.CustomerID AND O1.OrderDate < O2.OrderDate
GROUP BY CustomerID, Name
ORDER BY AvgDaysBetweenOrders ASC;

-- Query #15: Analyze Revenue by Payment Term
-- Purpose: Evaluate which payment terms are associated with the highest revenue contribution by suppliers.

SELECT 
    S.PaymentTerm, 
    FORMAT(SUM(OD.Quantity * OD.Price), 2) AS TotalRevenue,
    COUNT(DISTINCT S.SupplierID) AS TotalSuppliers
FROM Suppliers S
JOIN Products P ON S.SupplierID = P.SupplierID
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY S.PaymentTerm
ORDER BY TotalRevenue DESC;


