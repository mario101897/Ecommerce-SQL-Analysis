USE ecommerce;

-- Query #1: Calculate the total sales for the platform
-- Purpose: Summarize the revenue generated by all orders. Key metric to measure overall performance.
SELECT SUM(TotalAmount) AS TotalSales 
FROM Orders;

-- Query #2: Count the total number of customers
-- Purpose: Measure customer base growth or size. Useful for understanding market reach.
SELECT COUNT(*) AS TotalCustomers 
FROM Customers;

-- Query #3: Find the top-selling product categories
-- Purpose: Identify the most popular product categories by sales volume, informing marketing strategies and inventory decisions.
SELECT P.Category, SUM(OD.Quantity) AS TotalSold
FROM OrderDetails OD
JOIN Products P ON OD.ProductID = P.ProductID
GROUP BY P.Category
ORDER BY TotalSold DESC;

-- Query #4: Identify the most valuable customers (highest spending)
-- Purpose: Highlight the top 5 customers contributing the most revenue. Useful for loyalty programs or personalized promotions.
SELECT C.CustomerID, C.Name, SUM(O.TotalAmount) AS TotalSpent
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY TotalSpent DESC
LIMIT 5;

-- Query #5: Find products that need restocking (low inventory)
-- Purpose: Identify products with low inventory to prioritize restocking and avoid stockouts.
SELECT ProductID, ProductName, StockQuantity 
FROM Products
WHERE StockQuantity < 10
ORDER BY StockQuantity ASC;

-- Query #6: Calculate the average order value per customer
-- Purpose: Measure customer spending behavior. Identifies high-value customers for potential upselling or retention efforts.
SELECT C.CustomerID, C.Name, AVG(O.TotalAmount) AS AvgOrderValue
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY AvgOrderValue DESC;

-- Query #7: Find monthly sales trends
-- Purpose: Show sales performance over time to identify trends or seasonality.
SELECT DATE_FORMAT(OrderDate, '%Y-%m') AS Month, SUM(TotalAmount) AS MonthlySales
FROM Orders
GROUP BY Month
ORDER BY Month ASC;

-- Query #8: Customer segmentation based on spending
-- Purpose: Categorize customers into segments (e.g., high-value) for targeted marketing campaigns or promotions.
SELECT 
    C.CustomerID, 
    C.Name, 
    CASE 
        WHEN SUM(O.TotalAmount) > 1000 THEN 'High-Value'
        WHEN SUM(O.TotalAmount) BETWEEN 500 AND 1000 THEN 'Medium-Value'
        ELSE 'Low-Value'
    END AS CustomerSegment,
    SUM(O.TotalAmount) AS TotalSpent
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY TotalSpent DESC;

-- Query #9: Identify most profitable products
-- Purpose: Identify the top revenue-generating products. Helps focus on items driving profitability and guides procurement or promotion decisions.
SELECT 
    P.ProductID, 
    P.ProductName, 
    SUM(OD.Quantity * OD.Price) AS TotalRevenue
FROM Products P
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY P.ProductID, P.ProductName
ORDER BY TotalRevenue DESC
LIMIT 5;

-- Query #10: Supplier contribution to revenue
-- Purpose: Measure how much revenue each supplierâ€™s products generate. Useful for negotiations or evaluating supplier performance.
SELECT 
    S.SupplierID, 
    S.SupplierName, 
    SUM(OD.Quantity * OD.Price) AS RevenueGenerated
FROM Suppliers S
JOIN Products P ON S.SupplierID = P.SupplierID
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY S.SupplierID, S.SupplierName
ORDER BY RevenueGenerated DESC;

-- Query #11: Identify frequently bundled products
-- Purpose: Detect commonly purchased product pairs (bundles). Informs cross-selling strategies and bundle promotions.
SELECT 
    OD1.ProductID AS Product1, 
    P1.ProductName AS Product1Name, 
    OD2.ProductID AS Product2, 
    P2.ProductName AS Product2Name, 
    COUNT(*) AS BundleCount
FROM OrderDetails OD1
JOIN OrderDetails OD2 ON OD1.OrderID = OD2.OrderID AND OD1.ProductID < OD2.ProductID
JOIN Products P1 ON OD1.ProductID = P1.ProductID
JOIN Products P2 ON OD2.ProductID = P2.ProductID
GROUP BY Product1, Product2
ORDER BY BundleCount DESC
LIMIT 5;

-- Query #12: Predict stock-out risk
-- Purpose: Predict which products are at risk of stockout within the next 30 days based on average daily sales.
SELECT 
    P.ProductID, 
    P.ProductName, 
    P.StockQuantity, 
    AVG(OD.Quantity) AS AvgDailySales, 
    ROUND(P.StockQuantity / AVG(OD.Quantity), 2) AS DaysUntilStockOut
FROM Products P
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY P.ProductID, P.ProductName, P.StockQuantity
HAVING DaysUntilStockOut < 30
ORDER BY DaysUntilStockOut ASC;

-- Query #13: Lifetime value of customers (LTV)
-- Purpose: Calculate customer lifetime value (LTV) based on total revenue and average order value. Guides customer retention efforts.
SELECT 
    C.CustomerID, 
    C.Name, 
    SUM(O.TotalAmount) AS TotalRevenue, 
    COUNT(O.OrderID) AS TotalOrders, 
    SUM(O.TotalAmount) / COUNT(O.OrderID) AS AvgOrderValue
FROM Customers C
JOIN Orders O ON C.CustomerID = O.CustomerID
GROUP BY C.CustomerID, C.Name
ORDER BY TotalRevenue DESC;

-- Query #14: Revenue trends by category over time
-- Purpose: Analyze how revenue from each product category changes over time to spot trends or shifts in customer preferences.
SELECT 
    DATE_FORMAT(O.OrderDate, '%Y-%m') AS Month, 
    P.Category, 
    SUM(OD.Quantity * OD.Price) AS MonthlyRevenue
FROM Orders O
JOIN OrderDetails OD ON O.OrderID = OD.OrderID
JOIN Products P ON OD.ProductID = P.ProductID
GROUP BY Month, P.Category
ORDER BY Month ASC, MonthlyRevenue DESC;

-- Query #15: Average time between orders for each customer
-- Purpose: Measure customer buying frequency. Useful for creating personalized re-engagement strategies.
SELECT 
    CustomerID, 
    Name, 
    AVG(DATEDIFF(O2.OrderDate, O1.OrderDate)) AS AvgDaysBetweenOrders
FROM Customers C
JOIN Orders O1 ON C.CustomerID = O1.CustomerID
JOIN Orders O2 ON C.CustomerID = O2.CustomerID AND O1.OrderDate < O2.OrderDate
GROUP BY CustomerID, Name
ORDER BY AvgDaysBetweenOrders ASC;

-- Query #16: Analyze Revenue by Payment Term
-- Purpose: Evaluate which payment terms are associated with the highest revenue contribution by suppliers.
SELECT 
    S.PaymentTerm, 
    SUM(OD.Quantity * OD.Price) AS TotalRevenue,
    COUNT(DISTINCT S.SupplierID) AS TotalSuppliers
FROM Suppliers S
JOIN Products P ON S.SupplierID = P.SupplierID
JOIN OrderDetails OD ON P.ProductID = OD.ProductID
GROUP BY S.PaymentTerm
ORDER BY TotalRevenue DESC;

-- Query #17: Categorize Suppliers by Payment Terms and Low-Stock Products
-- Purpose: Identify how suppliers with specific payment terms perform in terms of stock availability.
SELECT 
    S.PaymentTerm, 
    COUNT(CASE WHEN P.StockQuantity < 10 THEN 1 END) AS LowStockProducts,
    COUNT(P.ProductID) AS TotalProducts,
    ROUND(COUNT(CASE WHEN P.StockQuantity < 10 THEN 1 END) / COUNT(P.ProductID) * 100, 2) AS LowStockPercentage
FROM Suppliers S
JOIN Products P ON S.SupplierID = P.SupplierID
GROUP BY S.PaymentTerm
HAVING LowStockPercentage > 20
ORDER BY LowStockPercentage DESC;
